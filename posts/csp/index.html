<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Implementing Content Security Policies, The Easy Way. | Kevin Pham</title><meta name=keywords content="playwright,js,content security policy,appsec"><meta name=description content="CSP's are a pain to write for legacy sites, but it doesn't have to be."><meta name=author content="Kevin Pham"><link rel=canonical href=https://deoxy.net/posts/csp><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.min.b50dea21cb69b925c783abc4870e38fef3e55317f404eef2740034ed7a1c0ac5.css integrity="sha256-tQ3qIctpuSXHg6vEhw44/vPlUxf0BO7ydAA07XocCsU=" rel="preload stylesheet" as=style><link rel=preload href=/resources/logo.jpg as=image><link rel=icon href=https://deoxy.net/resources/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://deoxy.net/resource/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://deoxy.net/resources/favicon-32x32.png><link rel=apple-touch-icon href=https://deoxy.net/resources/apple-touch-icon.png><link rel=mask-icon href=https://deoxy.net/resources/safari_pinned_tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.83.1"><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(a,e,f,g,b,c,d){a.GoogleAnalyticsObject=b,a[b]=a[b]||function(){(a[b].q=a[b].q||[]).push(arguments)},a[b].l=1*new Date,c=e.createElement(f),d=e.getElementsByTagName(f)[0],c.async=1,c.src=g,d.parentNode.insertBefore(c,d)}(window,document,'script','https://www.google-analytics.com/analytics.js','ga'),ga('create','UA-123-45','auto'),ga('send','pageview'))</script><meta property="og:title" content="Implementing Content Security Policies, The Easy Way."><meta property="og:description" content="CSP's are a pain to write for legacy sites, but it doesn't have to be."><meta property="og:type" content="article"><meta property="og:url" content="https://deoxy.net/posts/csp/"><meta property="og:image" content="https://deoxy.net/posts/csp/csp.gif"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-05-04T00:00:00+00:00"><meta property="article:modified_time" content="2021-05-04T00:00:00+00:00"><meta property="og:site_name" content="Kevin Pham"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://deoxy.net/posts/csp/csp.gif"><meta name=twitter:title content="Implementing Content Security Policies, The Easy Way."><meta name=twitter:description content="CSP's are a pain to write for legacy sites, but it doesn't have to be."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://deoxy.net/posts/"},{"@type":"ListItem","position":2,"name":"Implementing Content Security Policies, The Easy Way.","item":"https://deoxy.net/posts/csp/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Implementing Content Security Policies, The Easy Way.","name":"Implementing Content Security Policies, The Easy Way.","description":"CSP's are a pain to write for legacy sites, but it doesn't have to be.","keywords":["playwright","js","content security policy","appsec"],"articleBody":"What’s a CSP? TLDR: Use my Playwright script to generate comprehensive CSP’s quickly.\nOne of the mitigating defenses for XSS attacks and Clickjacking attacks is a good Content Security Policy (CSP). While not a pancea, it can effectively limit the severity of any exploits by constraining the XSS payload size to the injection window, which is typically limited to a few characters. Instead of externally loading a payload like , the entire payload must be encoded in the script evaluation window, effectively preventing nasty frameworks like BeEF from being loaded.\nCSP’s work by essentially “whitelisting” externally loaded content. If evil.com is not whitelisted for loading scripts, scripts from evil.com cannot be loaded into the site. Sounds great, right? Unfortunately, the reality is that CSPs are only enforced on 7% of the Alexa Top 1M sites.\nWhy is this? If you’ve ever tried implementing a CSP on a non-trivial site, you’ll know the number one difficulty is breaking the site by preventing legitimate content from being loaded– oftentime on pages you never expected to have content on. It’s no wonder top site owners are slow to implement CSPs.\nGiven an existing sites with tons of legacy content, how does one go about finding the specific external sources for each CSP directive? One answer could be opening up devtools and browsing a few pages of the site, then writing it by hand. This might be fine for a single tiny site. But what if you have an entire company’s worth of large sites to handle?\nContent Security Policy Generator (Chrome Extension) Luckily for us, there is a chrome extension called Content Security Policy (CSP) Generator which will help us generate a CSP on all visited links.\nHowever, we still need to visit all the links. You could click them all manually, but that would also take you ages. Besides, don’t you have more important things to do, such as sitting in meetings? Browser automation to the rescue!\nPlaywright I’ll be using Playwright, which is typically used to control a full browser via the Chrome DevTools protocol for QA testing purposes. It’s a fork of Puppeeteer. I prefer to use Playwright, due to it’s more user-friendly selector engine.\nThe advantage of using a full browser to crawl our site is that all dynamic content will be loaded. In this day and age, almost all sites are built using some javascript framework, which means a full browser is necessary to load all content for the Chrome extension to evaluate, leading to a more airtight CSP.\nWriting the script Downloading the chrome extension Instead of downloading the chrome extension by going to the web store, we will use curl to download the .crx source file. This is so we can load our plugin into playwright after we unzip it.\nWe will also use a free CORS reverse proxy called CORS Anywhere, in order to bypass the Chrome webstore’s security policy. If we don’t do this, the resulting response body will be empty.\nextension_id=\"ahlnecfloencbkpfnpljbojmjkfgnmdc\" curl -s -L -o \"./csper.zip\" \"https://cors-anywhere.herokuapp.com/https://clients2.google.com/service/update2/crx?response=redirect\u0026os=win\u0026arch=x86-64\u0026os_arch=x86-64\u0026nacl_arch=x86-64\u0026prod=chromiumcrx\u0026prodchannel=unknown\u0026prodversion=9999.0.9999.0\u0026acceptformat=crx2,crx3\u0026x=id%3D${extension_id}%26uc\" \\  -H 'Origin: https://robwu.nl'\\  -H 'Referer: https://robwu.nl/'\\  unzip -d \"csper-src\" \"csper.zip\" Loading the CSPer extension into Playwright Here, we provide some additional args to load the extension directory we just downloaded into Chrome. Note that we need to turn off headess mode for extensions to work.\n(async () = { const pathToExtension = require('path').join(__dirname, 'csper-src'); const userDataDir = './user-data-dir'; const browserContext = await chromium.launchPersistentContext(userDataDir,{ headless: false, args: [ `--disable-extensions-except=${pathToExtension}`, `--load-extension=${pathToExtension}` ] }); // get url to load from command line  cspUrl = process.argv.slice(2)[0] const page = await browserContext.newPage(); await page.goto(cspUrl) })() Crawling each page recursively In our playwright file, we define a function crawl() which will take a URL, scrape all  links off the page. This function uses another function called waitForNetworkSettled(), taken from this gist. It’s basically an alternative to page.waitForNavigation({ waitUntil: \"networkidle\"})), which waits until the page loads. In my experience, the native function is buggy and resolves too early, so I had to use an alternative.\nconst seenURLs = new Set() const crawl = async (url) = { // don't recrawl pages alrady visited  if (seenURLs.has(url)) { return } // only crawl pages that are within our base domain  seenURLs.add(url) if (!url.startsWith(cspUrl)) { return } // don't crawl documents  if (url.endsWith(\".pdf\") || url.endsWith(\".docx\") || url.endsWith(\".xlsx\")) { return } // define a request function that will wait until the page is loaded \t// will also scroll down to handle lazy-loaded items  const doRequest = waitForNetworkSettled(page, async () = { await page.goto(url, { waitutil: 'domcontentloaded' }) await page.evaluate(() = window.scrollTo(0, (document.body.scrollHeight/3))); }) // race the request function with a timeout function \t// this will allow page that don't stop loading assets to continue  await Promise.race([ doRequest, new Promise((_, reject) = setTimeout(() = reject(new Error('timeout')), 11.5e3)) ]).catch() try { // scrape new URLS off the page  const urls = await page.$$eval('a', (elements) = elements.map((el) = el.href), ) // recursively crawl them  for await (const u of urls) { await crawl(u) } } catch {} } Generating our CSP First, run the program.\nnode generate.js \"https://polb.com\" When the browser loads, click on the extension icon and start a new recording.\nThen, press enter to start recursively visiting all the URLs with the script.\nBe mindful of being banned if there is an anti-bot service running on the site. Set a delay between page loads if necessary.\nWhen it is done, generate your new CSP policy.\nDon’t forget to remove any inline scripts from your site.\nDeploying the CSP Voila! you are done. Now go deploy your CSP by adding the Content-Security-Policy:  header to your site, if you have control over the server. If you have control over the content, but not the server, you can add this html tag ” /.\nHopefully this saves you some time. Source code here if you’d like to use it.\n","wordCount":"975","inLanguage":"en","image":"https://deoxy.net/posts/csp/csp.gif","datePublished":"2021-05-04T00:00:00Z","dateModified":"2021-05-04T00:00:00Z","author":{"@type":"Person","name":"Kevin Pham"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://deoxy.net/posts/csp/"},"publisher":{"@type":"Organization","name":"Kevin Pham","logo":{"@type":"ImageObject","url":"https://deoxy.net/resources/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script><noscript><style type=text/css>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:#1d1e20;--entry:#2e2e33;--primary:rgba(255, 255, 255, 0.84);--secondary:rgba(255, 255, 255, 0.56);--tertiary:rgba(255, 255, 255, 0.16);--content:rgba(255, 255, 255, 0.74);--hljs-bg:#2e2e33;--code-bg:#37383e;--border:#333}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://deoxy.net/ accesskey=h title="Kevin Pham (Alt + H)"><img src=/resources/logo.jpg alt=logo aria-label=logo height=40>Kevin Pham</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://deoxy.net/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li><li><a href=https://deoxy.net/archive/ title=archive><span>archive</span></a></li><li><a href=https://deoxy.net/tags/ title=tags><span>tags</span></a></li><li><a href=https://keybase.io/deoxy title=contact><span>contact</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Implementing Content Security Policies, The Easy Way.</h1><div class=post-description>CSP's are a pain to write for legacy sites, but it doesn't have to be.</div><div class=post-meta>May 4, 2021&nbsp;·&nbsp;5 min&nbsp;·&nbsp;Kevin Pham&nbsp;|&nbsp;<a href=https://gitlab.com/deoxykev/content/posts/csp/index.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><figure class=entry-cover><img loading=lazy src=https://deoxy.net/posts/csp/csp.gif alt="Generating a CSP using a playwright script"></figure><div class=toc><details><summary accesskey=c title="(Alt + C)"><div class=details>Table of Contents</div></summary><div class=inner><ul><li><a href=#whats-a-csp aria-label="What&amp;rsquo;s a CSP?">What&rsquo;s a CSP?</a></li><li><a href=#content-security-policy-generator-chrome-extension aria-label="Content Security Policy Generator (Chrome Extension)">Content Security Policy Generator (Chrome Extension)</a></li><li><a href=#playwright aria-label=Playwright>Playwright</a></li><li><a href=#writing-the-script aria-label="Writing the script">Writing the script</a><ul><li><a href=#downloading-the-chrome-extension aria-label="Downloading the chrome extension">Downloading the chrome extension</a></li><li><a href=#loading-the-csper-extension-into-playwright aria-label="Loading the CSPer extension into Playwright">Loading the CSPer extension into Playwright</a></li><li><a href=#crawling-each-page-recursively aria-label="Crawling each page recursively">Crawling each page recursively</a></li></ul></li><li><a href=#generating-our-csp aria-label="Generating our CSP">Generating our CSP</a><ul><li><a href=#deploying-the-csp aria-label="Deploying the CSP">Deploying the CSP</a></li></ul></li></ul></div></details></div><div class=post-content><h1 id=whats-a-csp>What&rsquo;s a CSP?<a hidden class=anchor aria-hidden=true href=#whats-a-csp>#</a></h1><p>TLDR: Use <a href=https://github.com/deoxykev/quickcsp>my Playwright script</a> to generate comprehensive CSP&rsquo;s quickly.</p><p>One of the mitigating defenses for <a href=https://portswigger.net/web-security/cross-site-scripting>XSS attacks</a> and <a href=https://portswigger.net/web-security/clickjacking>Clickjacking attacks</a> is a good Content Security Policy (CSP). While not a pancea, it can effectively limit the severity of any exploits by constraining the XSS payload size to the injection window, which is typically limited to a few characters. Instead of externally loading a payload like <code>&lt;script src="https://evil.com/payload.js/></code>, the entire payload must be encoded in the script evaluation window, effectively preventing nasty frameworks like <a href=https://beefproject.com/>BeEF</a> from being loaded.</p><p><img loading=lazy src=./csp_intro.png alt="CSP Explaination"></p><p>CSP&rsquo;s work by essentially &ldquo;whitelisting&rdquo; externally loaded content. If <code>evil.com</code> is not whitelisted for loading scripts, scripts from <code>evil.com</code> cannot be loaded into the site. Sounds great, right? Unfortunately, the reality is that CSPs are only <a href=https://www.rapid7.com/blog/post/2020/11/02/overview-of-content-security-policies-csp-on-the-web/>enforced on 7% of the Alexa Top 1M sites</a>.</p><p>Why is this? If you&rsquo;ve ever tried implementing a CSP on a non-trivial site, you&rsquo;ll know the number one difficulty is breaking the site by preventing legitimate content from being loaded&ndash; oftentime on pages you never expected to have content on. It&rsquo;s no wonder top site owners are slow to implement CSPs.</p><p>Given an existing sites with tons of legacy content, how does one go about finding the specific external sources for each <a href=https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy>CSP directive</a>? One answer could be opening up devtools and browsing a few pages of the site, then writing it by hand. This might be fine for a single tiny site. But what if you have an entire company&rsquo;s worth of large sites to handle?</p><h1 id=content-security-policy-generator-chrome-extension>Content Security Policy Generator (Chrome Extension)<a hidden class=anchor aria-hidden=true href=#content-security-policy-generator-chrome-extension>#</a></h1><p>Luckily for us, there is a chrome extension called <a href="https://chrome.google.com/webstore/detail/content-security-policy-c/ahlnecfloencbkpfnpljbojmjkfgnmdc?hl=en">Content Security Policy (CSP) Generator</a> which will help us generate a CSP on all visited links.</p><p>However, we still need to visit all the links. You could click them all manually, but that would also take you ages. Besides, don&rsquo;t you have more important things to do, such as sitting in meetings? Browser automation to the rescue!</p><h1 id=playwright>Playwright<a hidden class=anchor aria-hidden=true href=#playwright>#</a></h1><p>I&rsquo;ll be using <a href=https://playwright.dev/>Playwright</a>, which is typically used to control a full browser via the Chrome DevTools protocol for QA testing purposes. It&rsquo;s a fork of <a href=https://github.com/puppeteer/puppeteer>Puppeeteer</a>. I prefer to use Playwright, due to it&rsquo;s more user-friendly <a href=https://playwright.dev/docs/1.0.0/selectors/>selector engine</a>.</p><p>The advantage of using a full browser to crawl our site is that all dynamic content will be loaded. In this day and age, almost all sites are built using some javascript framework, which means a full browser is necessary to load all content for the Chrome extension to evaluate, leading to a more airtight CSP.</p><h1 id=writing-the-script>Writing the script<a hidden class=anchor aria-hidden=true href=#writing-the-script>#</a></h1><h2 id=downloading-the-chrome-extension>Downloading the chrome extension<a hidden class=anchor aria-hidden=true href=#downloading-the-chrome-extension>#</a></h2><p>Instead of downloading the <a href=https://chrome.google.com/webstore/detail/content-security-policy-c/ahlnecfloencbkpfnpljbojmjkfgnmdc>chrome extension</a> by going to the web store, we will use curl to download the <code>.crx</code> source file. This is so we can load our plugin into playwright after we unzip it.</p><p>We will also use a free <a href=https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS>CORS</a> reverse proxy called <a href=https://github.com/Rob--W/cors-anywhere>CORS Anywhere</a>, in order to bypass the Chrome webstore&rsquo;s security policy. If we don&rsquo;t do this, the resulting response body will be empty.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>extension_id<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;ahlnecfloencbkpfnpljbojmjkfgnmdc&#34;</span>

curl -s -L -o <span style=color:#e6db74>&#34;./csper.zip&#34;</span> <span style=color:#e6db74>&#34;https://cors-anywhere.herokuapp.com/https://clients2.google.com/service/update2/crx?response=redirect&amp;os=win&amp;arch=x86-64&amp;os_arch=x86-64&amp;nacl_arch=x86-64&amp;prod=chromiumcrx&amp;prodchannel=unknown&amp;prodversion=9999.0.9999.0&amp;acceptformat=crx2,crx3&amp;x=id%3D</span><span style=color:#e6db74>${</span>extension_id<span style=color:#e6db74>}</span><span style=color:#e6db74>%26uc&#34;</span> <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>  -H <span style=color:#e6db74>&#39;Origin: https://robwu.nl&#39;</span><span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>  -H <span style=color:#e6db74>&#39;Referer: https://robwu.nl/&#39;</span><span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>
unzip -d <span style=color:#e6db74>&#34;csper-src&#34;</span> <span style=color:#e6db74>&#34;csper.zip&#34;</span>
</code></pre></div><h2 id=loading-the-csper-extension-into-playwright>Loading the CSPer extension into Playwright<a hidden class=anchor aria-hidden=true href=#loading-the-csper-extension-into-playwright>#</a></h2><p>Here, we provide some additional args to load the extension directory we just downloaded into Chrome. Note that we need to turn off headess mode for extensions to work.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js>(<span style=color:#66d9ef>async</span> () =&gt; {
  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>pathToExtension</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>require</span>(<span style=color:#e6db74>&#39;path&#39;</span>).<span style=color:#a6e22e>join</span>(<span style=color:#ae81ff>__</span><span style=color:#a6e22e>dirname</span>, <span style=color:#e6db74>&#39;csper-src&#39;</span>);
  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>userDataDir</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;./user-data-dir&#39;</span>;
  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>browserContext</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>chromium</span>.<span style=color:#a6e22e>launchPersistentContext</span>(<span style=color:#a6e22e>userDataDir</span>,{
    <span style=color:#a6e22e>headless</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>false</span>,
    <span style=color:#a6e22e>args</span><span style=color:#f92672>:</span> [
      <span style=color:#e6db74>`--disable-extensions-except=</span><span style=color:#e6db74>${</span><span style=color:#a6e22e>pathToExtension</span><span style=color:#e6db74>}</span><span style=color:#e6db74>`</span>,
      <span style=color:#e6db74>`--load-extension=</span><span style=color:#e6db74>${</span><span style=color:#a6e22e>pathToExtension</span><span style=color:#e6db74>}</span><span style=color:#e6db74>`</span>
    ]
  });

  <span style=color:#75715e>// get url to load from command line 
</span><span style=color:#75715e></span>  <span style=color:#a6e22e>cspUrl</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>process</span>.<span style=color:#a6e22e>argv</span>.<span style=color:#a6e22e>slice</span>(<span style=color:#ae81ff>2</span>)[<span style=color:#ae81ff>0</span>]

  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>page</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>browserContext</span>.<span style=color:#a6e22e>newPage</span>();
  <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>page</span>.<span style=color:#66d9ef>goto</span>(<span style=color:#a6e22e>cspUrl</span>)
})()
</code></pre></div><h2 id=crawling-each-page-recursively>Crawling each page recursively<a hidden class=anchor aria-hidden=true href=#crawling-each-page-recursively>#</a></h2><p>In our playwright file, we define a function <code>crawl()</code> which will take a URL, scrape all <code>&lt;a href=""/></code> links off the page. This function uses another function called <code>waitForNetworkSettled()</code>, taken from this <a href=https://gist.github.com/dgozman/d1c46f966eb9854ee1fe24960b603b28>gist</a>. It&rsquo;s basically an alternative to <code>page.waitForNavigation({ waitUntil: "networkidle"}))</code>, which waits until the page loads. In my experience, the native function is buggy and resolves too early, so I had to use an alternative.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>seenURLs</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>Set</span>()
  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>crawl</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>async</span> (<span style=color:#a6e22e>url</span>) =&gt; {
	<span style=color:#75715e>// don&#39;t recrawl pages alrady visited
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>seenURLs</span>.<span style=color:#a6e22e>has</span>(<span style=color:#a6e22e>url</span>)) {
      <span style=color:#66d9ef>return</span>
    }

	<span style=color:#75715e>// only crawl pages that are within our base domain
</span><span style=color:#75715e></span>    <span style=color:#a6e22e>seenURLs</span>.<span style=color:#a6e22e>add</span>(<span style=color:#a6e22e>url</span>)
    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span><span style=color:#a6e22e>url</span>.<span style=color:#a6e22e>startsWith</span>(<span style=color:#a6e22e>cspUrl</span>)) {
      <span style=color:#66d9ef>return</span>
    }
    
	<span style=color:#75715e>// don&#39;t crawl documents
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>url</span>.<span style=color:#a6e22e>endsWith</span>(<span style=color:#e6db74>&#34;.pdf&#34;</span>) <span style=color:#f92672>||</span> <span style=color:#a6e22e>url</span>.<span style=color:#a6e22e>endsWith</span>(<span style=color:#e6db74>&#34;.docx&#34;</span>) <span style=color:#f92672>||</span> <span style=color:#a6e22e>url</span>.<span style=color:#a6e22e>endsWith</span>(<span style=color:#e6db74>&#34;.xlsx&#34;</span>)) {
        <span style=color:#66d9ef>return</span>
    }

	<span style=color:#75715e>// define a request function that will wait until the page is loaded
</span><span style=color:#75715e></span>	<span style=color:#75715e>// will also scroll down to handle lazy-loaded items 
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>doRequest</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>waitForNetworkSettled</span>(<span style=color:#a6e22e>page</span>, <span style=color:#66d9ef>async</span> () =&gt; {
        <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>page</span>.<span style=color:#66d9ef>goto</span>(<span style=color:#a6e22e>url</span>, { <span style=color:#a6e22e>waitutil</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;domcontentloaded&#39;</span> })
        <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>page</span>.<span style=color:#a6e22e>evaluate</span>(() =&gt; window.<span style=color:#a6e22e>scrollTo</span>(<span style=color:#ae81ff>0</span>, (document.<span style=color:#a6e22e>body</span>.<span style=color:#a6e22e>scrollHeight</span><span style=color:#f92672>/</span><span style=color:#ae81ff>3</span>)));
    })

	<span style=color:#75715e>// race the request function with a timeout function
</span><span style=color:#75715e></span>	<span style=color:#75715e>// this will allow page that don&#39;t stop loading assets to continue
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>await</span> Promise.<span style=color:#a6e22e>race</span>([
      <span style=color:#a6e22e>doRequest</span>, 
      <span style=color:#66d9ef>new</span> Promise((<span style=color:#ae81ff>_</span>, <span style=color:#a6e22e>reject</span>) =&gt; <span style=color:#a6e22e>setTimeout</span>(() =&gt; <span style=color:#a6e22e>reject</span>(<span style=color:#66d9ef>new</span> Error(<span style=color:#e6db74>&#39;timeout&#39;</span>)), <span style=color:#ae81ff>11.5</span><span style=color:#a6e22e>e3</span>))
    ]).<span style=color:#66d9ef>catch</span>()

    <span style=color:#66d9ef>try</span> {
	  <span style=color:#75715e>// scrape new URLS off the page 
</span><span style=color:#75715e></span>      <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>urls</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>page</span>.<span style=color:#a6e22e>$$eval</span>(<span style=color:#e6db74>&#39;a&#39;</span>, (<span style=color:#a6e22e>elements</span>) =&gt;
          <span style=color:#a6e22e>elements</span>.<span style=color:#a6e22e>map</span>((<span style=color:#a6e22e>el</span>) =&gt; <span style=color:#a6e22e>el</span>.<span style=color:#a6e22e>href</span>),
      )

	  <span style=color:#75715e>// recursively crawl them
</span><span style=color:#75715e></span>      <span style=color:#66d9ef>for</span> <span style=color:#66d9ef>await</span> (<span style=color:#66d9ef>const</span> <span style=color:#a6e22e>u</span> <span style=color:#66d9ef>of</span> <span style=color:#a6e22e>urls</span>) {
          <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>crawl</span>(<span style=color:#a6e22e>u</span>)
      }
    } <span style=color:#66d9ef>catch</span> {}
  }
</code></pre></div><h1 id=generating-our-csp>Generating our CSP<a hidden class=anchor aria-hidden=true href=#generating-our-csp>#</a></h1><p>First, run the program.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>node generate.js <span style=color:#e6db74>&#34;https://polb.com&#34;</span>
</code></pre></div><p>When the browser loads, click on the extension icon and start a new recording.</p><p><img loading=lazy src=./csp_start.png alt="Starting the CSPer Extension"></p><p>Then, press enter to start recursively visiting all the URLs with the script.</p><p><img loading=lazy src=./fast_typing.gif alt="Fast Typing">
<img loading=lazy src=./csp.gif alt="Quick CSP Demo"></p><p>Be mindful of being banned if there is an anti-bot service running on the site. Set a delay between page loads if necessary.</p><p>When it is done, generate your new CSP policy.</p><p><img loading=lazy src=./csp_gen.png alt="Generating a CSP"></p><p>Don&rsquo;t forget to remove any inline scripts from your site.</p><p><img loading=lazy src=./csp_inline.png alt="Removing Inline Scripts"></p><h2 id=deploying-the-csp>Deploying the CSP<a hidden class=anchor aria-hidden=true href=#deploying-the-csp>#</a></h2><p>Voila! you are done. Now go deploy your CSP by adding the <code>Content-Security-Policy: &lt;your_generated_csp></code> header to your site, if you have control over the server. If you have control over the content, but not the server, you can add this html tag <code>&lt;meta http-equiv=”Content-Security-Policy” content=”&lt;your_generated_csp>” /></code>.</p><p>Hopefully this saves you some time. <a href=https://github.com/deoxykev/quickcsp>Source code here</a> if you&rsquo;d like to use it.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://deoxy.net/tags/playwright/>playwright</a></li><li><a href=https://deoxy.net/tags/js/>js</a></li><li><a href=https://deoxy.net/tags/content-security-policy/>content security policy</a></li><li><a href=https://deoxy.net/tags/appsec/>appsec</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2021 <a href=https://deoxy.net/>Kevin Pham</a></span>
<span>| <a href=/pgp>PGP</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)"><button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></button></a>
<script>let menu=document.getElementById('menu');menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)},document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script></body></html>